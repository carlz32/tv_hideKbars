//@version=6
indicator("SessionFilter & Bar Counter & EMA", overlay=true, max_labels_count = 500, max_lines_count = 500)
SESSION_GROUP = "会话"
COUNTER_GROUP = "计数"
EMA_GROUP = "EMA"
LEVELS_GROUP = "水平射线"

// Session Filter
// Inputs (defaults kept as before)
sess = input.session("0930-1600", "会话时段", group = SESSION_GROUP)
sessTz = input.string("UTC+8", "会话时区(空=图表时区)", group = SESSION_GROUP)
shadeSession = input.bool(true, "会话背景着色", group = SESSION_GROUP)
shadeColor = input.color(color.new(color.orange, 85), "会话背景颜色", group = SESSION_GROUP)

levelsEnabled = input.bool(true, "绘制会话水平射线", group = LEVELS_GROUP)
color levelColorClose = input(color.gray, "收盘射线颜色", group = LEVELS_GROUP)
color levelColorHigh = input(color.green, "最高射线颜色", group = LEVELS_GROUP)
color levelColorLow = input(color.red, "最低射线颜色", group = LEVELS_GROUP)
levelWidth = input.int(1, "射线宽度", minval = 1, maxval = 5, group = LEVELS_GROUP)
labelOffsetBars = input.int(20, "标签右侧偏移(根数)", minval = 0, maxval = 50, group = LEVELS_GROUP)
rayLabelSizeOption = input.string(title = "标签尺寸", options = ["Large", "Normal", "Small"], defval = "Small", group = LEVELS_GROUP)
rayLabelSize = rayLabelSizeOption == "Large" ? size.large : rayLabelSizeOption == "Small" ? size.small : size.normal

// Session detection
t_in = time(timeframe.period, sess, sessTz) // NaN if not in session
inSession = not na(t_in)

// Shade (use color variable and plain 'na')
color shade_to_use = na
shade_to_use := shadeSession ? (inSession ? shadeColor : na) : na
bgcolor(shade_to_use, title="Session shading")

// Bar Counter
// Input
sizeOption = input.string(title = '标签尺寸', options = ['Auto', 'Huge', 'Large', 'Normal', 'Small', 'Tiny'], defval = 'Normal', group = COUNTER_GROUP)
labelSize = sizeOption == 'Huge' ? size.huge : sizeOption == 'Large' ? size.large : sizeOption == 'Small' ? size.small : sizeOption == 'Tiny' ? size.tiny : sizeOption == 'Auto' ? size.auto : size.normal
color c_labelColor = input(color.orange, 'Text Color', group = COUNTER_GROUP)
c_contador = input(title = 'Display at every X bars', defval = 3, group = COUNTER_GROUP)
// Session bar counter: detect session first bar and count bars while inSession
var int sessBarCount = 0
// first bar of session: currently inSession and previous bar was not inSession
int prevInInt = nz(inSession[1] ? 1 : 0)
bool isFirstSessionBar = inSession and prevInInt == 0
if isFirstSessionBar
    sessBarCount := 1
else
    sessBarCount := inSession ? nz(sessBarCount) + 1 : 0

if inSession and sessBarCount % c_contador == 0
    label countLabel = label.new(bar_index, 0, style = label.style_none, text = str.tostring(sessBarCount))
    
    label.set_yloc(countLabel, yloc.belowbar)
    label.set_textcolor(countLabel, c_labelColor)
    label.set_size(countLabel, labelSize)

var float sessHigh = na
var float sessLow = na
var float sessClose = na
var line rayClose = na
var line rayHigh = na
var line rayLow = na
var label labClose = na
var label labHigh = na
var label labLow = na
if isFirstSessionBar
    sessHigh := high
    sessLow := low
    sessClose := close
else
    if inSession
        sessHigh := math.max(nz(sessHigh), high)
        sessLow := na(sessLow) ? low : math.min(sessLow, low)
        sessClose := close
bool sessionEnded = not inSession and prevInInt == 1
if levelsEnabled and sessionEnded
    if not na(rayClose)
        line.delete(rayClose)
    if not na(rayHigh)
        line.delete(rayHigh)
    if not na(rayLow)
        line.delete(rayLow)
    if not na(labClose)
        label.delete(labClose)
    if not na(labHigh)
        label.delete(labHigh)
    if not na(labLow)
        label.delete(labLow)
    rayClose := line.new(bar_index[1], sessClose, bar_index, sessClose)
    line.set_color(rayClose, levelColorClose)
    line.set_width(rayClose, levelWidth)
    line.set_style(rayClose, line.style_solid)
    line.set_extend(rayClose, extend.right)
    labClose := label.new(bar_index + labelOffsetBars, sessClose, "C", xloc.bar_index, yloc.price, na, label.style_none, levelColorClose, rayLabelSize)
    rayHigh := line.new(bar_index[1], sessHigh, bar_index, sessHigh)
    line.set_color(rayHigh, levelColorHigh)
    line.set_width(rayHigh, levelWidth)
    line.set_style(rayHigh, line.style_solid)
    line.set_extend(rayHigh, extend.right)
    labHigh := label.new(bar_index + labelOffsetBars, sessHigh, "H", xloc.bar_index, yloc.price, na, label.style_none, levelColorHigh, rayLabelSize)
    rayLow := line.new(bar_index[1], sessLow, bar_index, sessLow)
    line.set_color(rayLow, levelColorLow)
    line.set_width(rayLow, levelWidth)
    line.set_style(rayLow, line.style_solid)
    line.set_extend(rayLow, extend.right)
    labLow := label.new(bar_index + labelOffsetBars, sessLow, "L", xloc.bar_index, yloc.price, na, label.style_none, levelColorLow, rayLabelSize)

if levelsEnabled
    if not na(labClose)
        label.set_x(labClose, bar_index + labelOffsetBars)
    if not na(labHigh)
        label.set_x(labHigh, bar_index + labelOffsetBars)
    if not na(labLow)
        label.set_x(labLow, bar_index + labelOffsetBars)

// EMA
//Input
lenOption = input.int(title = 'EMA长度', defval = 20, group = EMA_GROUP)
// 开关：仅会话内绘制（开启 = 会话感知并在会话间延续；关闭 = 常规连续 EMA）
sessionOnlyEMA = input.bool(true, "仅会话EMA", group = EMA_GROUP)
ema_cur  = ta.ema(close, lenOption)
// 实现：会话内根据 close 更新 EMA，会话外保持上次值（水平延伸）；下一会话从该值继续计算
// 自定义 EMA 递推：ema = alpha * price + (1 - alpha) * ema[1]

alpha = 2.0 / (lenOption + 1.0)

// 当前周期 EMA（stateful，以保持跨会话的最后值）
// 根据开关选择 EMA 行为
var float ema_cur_state = na
float ema_cur_plot = na
if sessionOnlyEMA
	if inSession
		// 在会话内：正常根据收盘价迭代更新 EMA
		ema_cur_state := na(ema_cur_state) ? close : alpha * close + (1 - alpha) * nz(ema_cur_state)
	else
		// 会话外：保持上次会话的值（不更新）
		ema_cur_state := nz(ema_cur_state)
	// 根据模式决定绘制值（在局部赋值，但 plot 在全局）
	ema_cur_plot := ema_cur_state
else
	// 常规模式：直接使用连续的 ta.ema 作为绘制系列
	ema_cur_plot := ta.ema(close, lenOption)

// 在全局绘制一次，避免在局部作用域中调用 plot
plot(ema_cur_plot, color = color.blue, title = "EMA20 Current")

// 1 小时 EMA：我们在 1h 周期内也使用同样的逻辑，但需在 request.security 内部维护状态
// 创建一个函数化表达式，通过 request.security 调用以在 1h 时间框架上正确递推
f_ema_session(src, length) =>
	float res = na
	float a = 2.0 / (length + 1.0)
	var float s = na
	bool inS = not na(time(timeframe.period, sess, sessTz))
	if inS
		s := na(s) ? src : a * src + (1 - a) * nz(s)
	else
		s := nz(s)
	res := s
	res

ema_1h_state = sessionOnlyEMA ? request.security(syminfo.tickerid, "60", f_ema_session(close, lenOption)) : request.security(syminfo.tickerid, "60", ta.ema(close, lenOption))
plot(ema_1h_state, color = color.teal, linewidth = 2, title = "EMA20 1h")
